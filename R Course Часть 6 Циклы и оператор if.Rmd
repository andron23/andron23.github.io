---
title: "R Course Часть 6 Циклы и оператор if"
author: "Alexanyan Andron"
output: 
  html_document:
   toc: TRUE
   toc_float: TRUE
   theme: "readable"
   highlight: "textmate"
---

```{r setup_6, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Часть 6 Циклы и оператор if

Наш базовый курс уже подходит к концу, но мы не обсудили еще одну очень важную тему - циклы и применение оператора ```if```. В простых аналитических задачах Вы можете и не встретиться с этим функционалом, но как только кейсы станут чуть сложнее, Вам однозначно это понадобится. 

## Оператор if

Давайте начнем с оператора ```if```. Думаю, большинству людей эта конструкция должна быть понятна, ведь все так или иначе использовали формулу ```если()``` в Excel. В любом случае, давайте подробно рассмотрим полную структуру оператора ```if```: 



```{r if_struct, eval = FALSE}

if (условие 1) {
  тогда делаем так
} else if (условие 2) {
  тогда делаем так
} else {
  делаем так
}

```

Блок ```else if``` может фигурировать сколько угодно раз, в то время как ```if```и ```else``` могут встречаться только один раз - в начале и в конце, соответственно. 

Сначала проверяется условие в ```if``` - ```условие 1```. Если оно не верно, проверяется ```условие 2``` и так далее до конца. Если ни одно из условий не выполнилось, то будет обработан заключительный код из блока ```else```. Давайте в качестве примера создадим простенький условный обработчик: он будет принимать на вход число и проверять, оно больше нуля/меньше нуля или равно нулю. 

```{r if_1}

a <- sample(-5:5, 1) #генерируем случайное число от 1 до 5

if(a > 0){
  
  print("Это положительное число")
  
}else if(a == 0){
  
  print("Это нуль")
  
}else{
  
  print("Это отрицательное число")
  
}

```

Само собой, внутри ```if``` могут быть и более сложные инструкции (т.е. набор кода) - Вы можете прям там делать какой-то расчет, например. 

```{r if_2}

if(a**2 > 20){#проверяем условие
  
  a <- abs(a) #если условие выполняется, берем число по модулю
  vec <- rnorm(a) #генерируем вектор нормально распределенных величин длиной a
  print(vec)
}else{
  
  print("Условие не выполнилось!")
  
}

```

И так далее по нарастающей. Вы можете очень много всего написать в теле ```if```, если в этом есть необходимость - все будет обработано. 

## Цикл for

С циклами тоже, скорее всего, большинство из Вас встречались - ведь это просто выполнение повторяющихся действий. Если Вам нужно посчитать яблоки на столе (представим, что Вам 2 года и перед Вами лежит 5 яблок), то Вы бы делали так: ```1 + 1 + 1 + 1 + 1 = 5```. Каждый раз, прибавляя единичку, Вы бы тыкали пальцем в яблоко и произносили бы "плюс 1!". А вот если бы Вы могли запрограммировать свои пальцы (ну и голос еще), то Вы бы сделали так: 

```{r for_1}

for(apple in 1:5){
  
  print("Плюс 1!")
  
}

print(paste("Я насчитал ", apple, " яблок!")) #после выхода из цикла пишем, сколько яблок мы насчитали 

```

У Вас может возникнуть вопрос: "а почему apple стал равен 5, если мы ничего не прибавляли в цикле, а просто делали print"? ```apple``` в данном случае - переменная-счетчик. С каждым новым кругом цикла эта переменная увеличивается на единицу. Давайте проверим. 


```{r for_2}

for(apple in 1:5){
  
  print(apple)
  
}

```

Мы видим, что с каждым новым кругом переменная ```apple``` становится больше на один. 

На этом, собственно, все премудрости цикла ```for``` заканчиваются - далее просто усложняется само тело цикла, т.е. те команды, которые мы делаем на каждом круге цикла. Например: 

```{r for_3}

vec <- 1:10 

for(i in vec){
  
  if(i%%2 == 0){
    
    print(paste(i, " - четное число"))
    
  }else{
    
    print(paste(i, " - нечетное число"))
    
  }
  
}

```

Тут мы объединили сразу несколько конструкций - цикл ```for``` и условие ```if-else```. Как Вы можете видеть, наш цикл берет каждое число по порядку из вектора чисел от 1 до 10 и проверяет, является ли оно четным (находит остаток от деления и сравнивает его с нулем). После этого, в зависимости от ситуации, выводится нужное сообщение. 

Обратите внимание: в этом примере я в неявном виде указал ```i in vec```. Не обязательно после ```in``` явно указывать, как мы получаем вектор значений, ведь это может быть очень сложная конструкция. Значительно разумней в таком случае будет создать ее отдельно (как мы сделали с вектором ```vec```) и передать уже имя переменной после оператора ```in```. 

## Цикл while

Цикл ```while``` по своему смыслу почти ничем не отличается от ```for``` - он также просто выполняет повторяющиеся действия заданное количество раз. Основное отличие в том, что ```for``` работает, пока не "пробежит" весь заданный диапазон значений (например, все элементы вектора ```vec``` из предыдущего примера), а цикл ```while``` работает до выполнения какого-то условия. 

Например, мы можем воспользоваться тем же вектором ```vec```, но сказать, что хотим остановиться на числе 8. 

```{r while_1}

i = 1
while(vec[i] != 8){
  
  print(paste("Пока еще не дошли до 8, сейчас на", vec[i]))
  i = i + 1 
  
}

```

Таким образом мы можем выставлять любые условия остановки в ```where```. Это бывает особенно полезно, когда мы не знаем, когда конкретно нам нужно остановиться, но знаем условия для этого. Например, в математических расчетах часто бывает, что остановить расчет надо при достижении значения ошибки какого-то минимального порога. В таких случаях цикл ```while``` крайне полезен, хотя можно действовать и другими методами. 

## Заключение

В рамках этого базового курса по R мы разобрали все самые необходимые инструменты и функции языка R. Конечно же, их намного больше - под каждую задачу приходится придумывать и искать что-то индивидуальное, что подойдет и поможет именно сейчас. Это нормальный процесс, такое бывает при использовании всех языков программирования. Постоянно вылезают странные ошибки, что-то не получается - тогда на помощь приходят более опытные коллеги, интернет и официальная документация. Помимо всего прочего, у R очень активное коммьюнити и даже в процессе написания этого курса вышло несколько новых библиотек и обновлений, которые сразу же были мной изучены и внедрены в курс (например, подсветка изменений в коде в некоторых уроках). Это процесс итеративный и постоянный - чем больше реальных и учебных задач Вы будете решать, тем больше функций Вы будете знать, тем чище будет Ваш код и понятней конструкции. Мы с Вами решим еще ни одну задачу на R и выполним ни один проект, так что много чего интересного Вас еще ждет в процессе изучения. Удачи и помните - **дорогу осилит идущий**!