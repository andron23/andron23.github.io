---
title: "R Course Часть 4 - Функции"
author: "Alexanyan Andron"
output: 
  html_document:
   toc: TRUE
   theme: "readable"
   highlight: "textmate"
---

```{r setup_4, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
```

# Часть 4 Функции

В этом уроке мы будем обсуждать с Вами функции. На самом деле, с функциями мы с Вами работали с первого урока - даже стандартная ```is.numeric()``` - тоже функция, просто встроенные. Мы же обсудим, как создавать свои собственные пользователькие функции и как ими пользоваться потом. 

Давайте для начала немного формализуем и дадим определение, а что же вообще такое функция? Остановимся на таком определении: 

**Функция** - некоторый блок кода, выполняющий определенные операции, к которому можно обратиться в любом месте программы. 

Вообще говоря, считается, что функция должна быть именованным блоком кода, но во многих языках программирования (в том числе R) это не обязательно - допускаются безымянные функции. Об этом поговорим подробней чуть позже, а пока начнем с создания пользовательских функций. 

## Создание пользовательских функций

Мы создаем функцию, когда у нас есть некоторая последовательность действий, которую нам нужно будет выполнять периодически. Редко бывает, что однократное действие мы "засовываем" в функцию. Однако, это уже рассуждения из другого раздела - мы тут не обсуждаем, как правильно и красиво программировать, для этого существуют отдельные умные книжки. Мы тут говорим, как программировать удобно :) 

Итак, допустим у нас есть какая-то операция, которую нам периодически нужно выполнять и смотреть на результат. Пусть результат этой операции зависит от входных данных. Как создать функцию, чтобы каждый раз не писать полностью набор нужных нам команд, а просто ссылаться на функцию и указывать необходимые аргументы? 

Общая структура такая: 

```
имя_функции <- function(аргумент_1, аргумент_2...){

тело функции: набор команд с использованием аргумент_1, аргумент_2...

результат функции

}
```

Давайте создадим простейшую функцию, которая будет считать квадрат заданного числа. 

```{r square_function}

square <- function(x){
  
  res <- x**2
  return(res)
  
}

```

Мы создали функцию ```square()```, которая принимает на вход некоторое число ```x```, потом считает квадрат этого числа и возвращает результат. Теперь мы можем обратиться к этой функции, чтобы посчитать квадрат любого числа: 

```{r square_function_res}

square(2)
square(5)
square(105.6)
```

Кстати говоря, мы могли бы создать эту функцию даже короче: 

```{r square_function_1}

square <- function(x){
  
  return(x**2)
  
}

square(5)

```

Здесь мы пропускаем стадию с вычислением ```res``` внутри функции и сразу возвращаем значение квадрата. Если конструкция небольшая, иногда это бывает удобно, а иногда наоборот сознательно разбиваешь большой кусок кода на отдельные строки для наглядности и удобства восприятия. Одним словом - все индивидуально. 

Еще один момент - функция не обязательно должна принимать на вход аргументы. Например, давайте создадим функцию, которая генерирует вектор случайной длины. 

```{r random_vector}

randvec <- function(){
  
  len <- sample(1:100, 1) #генерируем случайное число от 1 до 100
  vec <- runif(len) #генерируем равномерно распределенные числа в количестве len штук
  return(vec)
  
}

randvec()

```

Что еще из интересного - функция может не возвращать ничего с помощью ```return()```, а просто делать какое-то действие. Например, записывать в файл или выводить на экран. Давайте создадим функцию, которая выводит на экран фразу ```"Привет! Мне х лет!"```, где ```х``` - аргумент функции. 

```{r hello_print}

hello <- function(x){
  
  print(paste("Привет! Мне ", x," лет!"))
  
}

hello(47)

```

Еще один момент - мы неоднократно сталкивались, когда у функции какие-то значения стоят по умолчанию. А мы так можем сделать? Конечно можем, причем очень просто! Создадим функцию, которая генерирует ```x``` чисел подряд (начиная с 1), а потом вычисляет некоторую степень этих чисел. По умолчанию поставим куб. 

```{r default_param}

pow <- function(x, power = 3){
  
  vec <- 1:x
  return(vec**power)
  
}

```

А теперь посмотрим, что будет, если мы не будем указывать аргумент ```power``` или укажем его в явном виде: 

```{r default_param_check}

pow(5) #Создаем вектор 1:5 и возводим в куб (по умолчанию)
pow(5,2) #Создаем вектор 1:5 и возводим в квадрат - указали параметр power в явном виде

```

## Анонимные функции

Иногда бывет ситуация, что нужно применить какую-то функцию к набору данных, а среди стандартных этой функции нет. Что делать? Заводит новую и только потом применять? А если она нам больше не понадобится, зачем код загрязнять? Это все очень резонные вопросы, на самом деле, и ответ на них есть - безымянные (или анонимные) функции. 

Единственное, чем отличаются анонимные функции от обычных - они не присваиваются никакой переменной, они просто выполняются и забываются системой. Если нам не нужно больше к этой функции обращаться - такой вариант нам очень подходит. 

Синтаксис такой: ```function(аргументы) тело```. 

Давайте рассмотрим на примере - подключим стандартный набор данных ```cars```, который содержит всего два столбца - скорость и тормозной путь; рассчитаем средние значения обоих столбцов, а потом посчитаем куб получившихся значений. Не спрашивайте зачем. Просто так, для примера :) 

```{r cars_anon}

data(cars) #Подключаем данные

cars %>% 
  summarise_all(list(mean)) %>% #Считаем среднее по каждому столбцу
  summarise_all(function(x)x**3) #Возводим результат в куб

```

Вы видите, что безымянная функция ```function(x)x**3``` позволила нам, не создавая отдельную именованную функцию, произвести вычисление. Это очень удобно и достаточно часто встречается при работе с пакетом ```dplyr```, при применении функция семейства ```sapply()```, ```lapply()``` и много когда еще. 

## Заключение

В этом уроке мы научились 

- создавать именованные функции
- создавать функции с аргументами по умолчанию 
- создавать функции, которые не возвращают значение
- работать с анонимными функциями

Это та основа, которая необходима каждому исследователю в ежедневной работе - функции помогают сделать Ваш код чище и красивей, при этом сократив количество строк за счет оптимизации повторяющихся действий. Качество кода, на самом деле, немаловажный момент. Новичок на это может не обращать внимания, но любой профессионал или просто опытный специалист легко определит Ваш уровень по качеству или хотя бы аккуратности Вашего кода. Так что осваивайте функции, пользуйтесь ими и делайте Ваш код читаемым, удобным и правильным!
