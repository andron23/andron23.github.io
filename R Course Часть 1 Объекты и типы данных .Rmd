---
title: 'R Course: Часть 1 - Объекты и типы данных'
author: "Alexanyan Andron"
output: 
  html_document:
   toc: TRUE
   theme: "readable"
   highlight: "textmate"
---

```{r setup1, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Часть 1 Объекты и типы данных

## Типы данных в языке R 

Каждый язык программирования работает с определенным стандартным набором типов данных. Для каждого типа определены свои  операции (например, арифмитические действия или сцепка текста), стандартные функции и прочие правила. В большинстве языков эти типы схожи: текст, числа, даты и так далее. Давайте подробней рассмотрим основные типы данных языка R, с которыми нам придется работать больше всего: 

- **numeric** - численный тип данных. Аналоги - *double* и *real*. Включает в себя и целые числа, и дроби. Для проверки, является ли объект типом *numeric*, используют функцию **is.numeric()**:

```{r isnumeric}
is.numeric(3.5)
is.numeric(2)
```

- **integer** - целочисленные данные. Включает в себя только целые числа. Диапазон данных +/- $2*10^9$. Скорее всего, Вам такого разбега хватит :) Аналогично предыдущему случаю, для проверки целочисленности используют функцию **is.integer()**, однако, она проверяет, явлется ли объект типом *integer* - а по умолчанию числа являются *numeric*, так что при попытке **is.integer(3)** Вы получите *FALSE*.  

```{r isinteger}
#По умолчанию 3 - numeric, так что получим FALSE. 
is.integer(3)
#Переведем в целые числа и проверим (хотя получается масло масляное)
is.integer(as.integer(3))
```

- **character** - символьный тип данных. Состоит из последовательностей различных символов. Может быть и одним символом. Помимо букв, числа, а также любые символы могут содержаться в *character*. Однако, надо помнить, что никаких вычислений с *character* мы делать не можем - сначала символы надо перевести в число с помощью функции **as.numeric()** и только потом можно делать расчеты. 

```{r ischar, error=TRUE}
is.character("jk15")
is.character("3.5")

#Переведем char в numeric и возведем в квадрат
as.numeric("3.5")^2

#Иначе будет ошибка 
"3.5"^2
```

- **complex** - специальный тип для комплексных чисел. Как и везде, проверка осуществляется с помощью **is.complex()**, а представить обычное число в комплексном виде (с нулевой мнимой частью) можно с помощью **as.complex()**: 

```{r iscomplex}
as.complex(1)
```

- **logical** - логический или булевский тип данных. Переменные такого типа могут принимать только два значения - *TRUE* или *FALSE*. Если перевести *logic* в *integer*, то из *TRUE* и *FALSE* получится 1 и 0, соответственно. 

```{r islogical}
#Верно ли: 2=1? Ответ - булева переменная: либо ДА, либо НЕТ. Проверим, действительно ли это логический тип данных? 
is.logical(2==1)
#А является ли logic текстовый тип данных? 
is.logical("test")
#Еще пример: верно ли, что 1 не больше 2? Такая запись - логический тип? 
is.logical(!1>2)
```

А что делать, если у нас вообще нет догадок, какой перед нами тип данных? Вообще, такую ситуацию, конечно, сложно представить, но вдруг... На этот случай существует функция **class**, которая позволяет определить тип данных. 

```{r classfunction}
#Как я и говорил - по умолчанию любое число идет как numeric
class(3)
#Так же и для чисел с плавающей точкой
class(3.5)
#Посмотрим, какая реакция будет на комплексные числа
class(1 + 2i)
#На строки: 
class("stroka")
#На булевы переменные: 
class(3>5)
```

## Создание объектов

Мы с Вами разобрались с основными типами данных, теперь давайте немного поговорим про создание простейших объектов, перед тем как переходить к более сложным конструкциям. 

До этого мы везде использовали числа, текст и логические выражения напрямую. Однако, при написании кода, нам постоянно придется присваивать то или иное значение каким-то переменным, чтобы не создавать их многократно и иметь возможность производить различные действия (например, арифметические). 

Как мы обсуждали в вводной лекции, язык R - интерпретируемый язык: он считывает и обрабатывает каждую строку в отдельности. Я часто привожу аналогию с калькулятором - ввел какие-то команды, интерпретатор их выполнил и запомнил. Удобно. В соответствии с этой концепцией, чтобы присвоить какой-то переменной значение, нам нужно просто написать конструкцию вида: 

```
переменная <- значение

```

Оператор *<-* - оператор присваивания, как бы аналог *=*. Между ними есть некоторая разница, и использование *=* вместо стрелочки иногда может вызывать проблемы. Но на практике, скорее всего, Вы встретите это очень не скоро, так что можете использовать знак равенства. И я Вам этого не говорил :) 

Кстати, обратите внимание, при создании переменной мы не указываем в явном виде тип данных (как, например, в С++: ```int i = 5```), что очень удобно. Однако, иногда с этим могут возникать проблемы - особенно на этапе загрузке данных из файлов нужно следить, чтобы все типы подгрузились правильно, а то потом долго и больно придется искать ошибку. 

Итак, пример:

```{r assignment}
x <- 5
y <- "abc"
z <- 5 + 3i
a <- !(1==2)

print(c(a,x,y,z))
```

Мы видим, что каждой переменной присвоилось некоторое значение, и с помощью команды print() мы вывели уже сами переменные. 

Однако, скорее всего, Вы обратили внимание, что в функции print() я использую какую-то пока что неизвестную нам конструкцию с(). Теперь наших знаний достаточно: мы можем двигаться дальше и обсудить это более подробно!

## Структуры данных 

Итак, давайте начнем с определения. 

**Структура данных** - программная единица, позволяющая работать с большим количеством однородных/логически связанных данных. Структуры данных также являются типами данных, но составными, поэтому под **типами данных** обычно подразумевают простые типы, рассмотренные выше, а **структуры данных** относят в отдельную группу. К стурктурам данных относятся *векторы, матрицы, массивы, фреймы, списки и факторы* - это основное. Рассмотрим все по порядку. 

### Однородные структуры. 

#### Векторы. 

Вектор - упорядоченная последовательность объектов одного типа. Обратите внимание - именно одного типа! То есть каждый вектор может состоять только из строк, только из чисел, только из дат, только из логических значений и так далее. Смеси быть не может! Вектор является, наверно, простейшей, но и самой основной структурой в R. На основе векторов создаются более сложные конструкции - фреймы, матрицы и так далее. 

**Замечание.** R вообще не работает со скалярами (т.е. одиночными значениями). Если у нас есть одно число или одна строка - на самом деле, это просто вектор одиночной длины. Обратите внимание, если Вы присвоите какой-то переменной значение, а потом вызовете ее, то слева будет стоять индекс 1. Этот индекс и показывает, что наше значение - всего лишь первый элемент в списке. 

```{r scalarvector}
x <- 5
print(x)
```

##### Создание вектора. 

Существует множество способов создать вектор. Вот основные: 

- Перечисление объектов
- Создание пустого вектора и заполнение его в процессе выполнения программы
- Генерация последовательности

Для **перечисления объектов** удобно пользоваться функцией с() - как раз той, о которой шла речь в конце предыдущего пункта. 
```{r enumeration}
x <- c(1,2,3,4,5)
print(x)

y <- c("a", "b", "c")
print(y)
```

Таким образом мы можем перечислять любые данные - численные, булевские, даты, символьные и так далее. Главное, чтобы было все одинаково. Иначе - ошибка.

```{r diff_enumeration}
x <- c(1,2,"a",2+3i)
print(x)
```

Но что мы видим - ошибки нет! А почему, я же ранее столько раз сказал, что все должно быть одинаково... Причина простая - автоматически все содержимое вектора приводится к одному типу данных. Если мы сделаем ``` class(x)```, то увидим, что все наши элементы вектора стали символьными - и числа, и комплексное число, и символы. Поэтому ошибку мы не получили, но стоит быть аккуратным - малейшее направильное действие приведет к ошибке: 

```{r error_enumeration, error=TRUE}
x <- c(1,2,"a",2+3i) + 1
```

Давайте теперь зададим вектор другим способом, например, **создадим пустой вектор и будем его заполнять в процессе**. 

В принципе, можно опять воспользоваться функцией **с()**: 

```{r с_empty_vector}
#Создаем пустой вектор
x <- c()
#Добавляем вручную первый и второй элемент 
x[1] <- 1
x[2] <- 2

print(x)
```

Но давайте для разнообразия воспользуемся другим способом - функцией **vector()**. У нее два аргумента - *mode* (тип данных, который будет в этом векторе "лежать") и *length* (количество элементов, которое планируется в векторе). 

```{r empty_vector}
#Создаем пустой вектор с целыми числами
x <- vector(mode = 'integer', length = 5)
#По умолчанию заполнен нулями
print(x)

#Создаем пустой вектор с символьными данными
y <- vector('character', 5)
#По умолчанию заполнен пустыми строками
print(y)
```

Обратите внимание, при создании второго вектора мы опустили название параметров и оставили только значения. Это общий принцип - если Вы указываете аргументы в том порядке, в котором требует функция, Вы можете не писать названия самих аргументов для краткости. Но иногда, особенно когда функции редкие, удобней прописывать аргументы в явном виде, чтобы потом не забыть самим и коллегам проще было смотреть Ваш код. 

Итак, нам осталось рассмотреть еще один способ задания вектора - **генерация последовательности**. Тут также есть несколько вариантов. 

- Можно использовать оператор **:**
- Можно использовать фунцию **seq()**

```{r vector_generator}
#Создаем последовательность с помощью оператора : 
indexes <- 1:7
indexes

indexes <- 5:-3
indexes

#У функции seq() нужно задать аргументы from, to и by (т.е. шаг разбиения). 
#Это не обязательные аргументы, но скорее всего, они Вам нужны :) 
indexes <- seq(from = 1, to = 2, by = 0.2)
indexes
```

У функции **seq()** есть и другие параметры, которые делают процесс генерации более гибким. Например, параметр *length.out* - количество элементов, которые нужно сгенерировать. 

**Замечание.** С помощью **seq()** мы можем генерировать не только последовательности чисел, но, например, и дат: 

```{r date_vector_generator}
#5 дат через 3 дня каждая, начиная с заданной даты
seq(from = as.Date('2020/01/01'), by = 3, length.out = 5)
```

Помимо указанных методов генерации последовательностей, часто возникает необходимость сгенерировать последовательность случайных чисел с заданным распределением. Об этом подробней мы будем говорить позже, а пока рассмотрим самые популярные - **runif()** и **rnorm()** - равномерное и нормальное распределение. 

```{r random_generator}
#10 чисел, распределеных равномерно от 0 до 25
runif(10, 0, 25)
#5 чисел, распределеных нормально с матожиданием 0 и st.dev 50
rnorm(5, 0, 50)
```


##### Индексация

В принципе, мы это уже делали, просто не обращали на это отдельное внимание - мы можем обращаться к любому элементу вектора по его индексу. Причем не важно - это первый элемент, 5 или последний. 

```{r indexing}
#Создаем вектор чисел от 1 до 10 
x <- 1:10 

#Вызываем 1 элемент 
x[1]

#Вызываем 3 элемент 
x[3]
```

Длину вектора мы можем узнать с помощью функции **length()**. Соответственно, чтобы вызвать последний элемент, можем сделать так: 

```{r n_indexing}
#Создаем вектор чисел от 1 до 10 
x <- 1:10 
len <- length(x)

#Вызываем последний элемент 
x[len]
```

Само собой, вызывать мы можем не только один элемент вектора, а сразу несколько. Для этого в качестве индекса нужно передать вектор индексов. Таким образом, мы можем использовать векторы, чтобы делать "срезы" или "подвекторы" исходных векторов. Причем, что важно - индексы не обязательно должны идти по порядку!

```{r cut_indexing}
#Создаем вектор чисел от 1 до 10 
x <- 1:10 
#Создаем вектор индексов от 3 до 5
indexes <- 3:5
#Делаем срез - выбираем из х с 3 по 5 элементы 
x[indexes]

#Делаем срез - выбираем из х отдельные элементы 
x[c(1,4,7,8)]
```

**Замечание.** В большинстве популярных языков программирования индексация векторов начинается с 0 и заканчивается числом *(длина вектора - 1)*. Т.е. если у нас был бы вектор из 5 элементов в Python, например, то первый элемент вызывался бы с помощью x[0], а последний - x[4]. В языке R же нумерация начинается с 1. Будьте осторожны, особенно, если программируете на нескольких языках.  

##### Преобразование

Сами по себе наборы данных, которые "засунули" в векторы, никакого интереса не несут. Все это делается, чтобы что-то можно было посчитать, как-то обработать, что-то нарисовать и так далее. Давайте последовательно со всем разберемся - начнем с расчетов и преобразований. 

Самое простое и очевидное, что можно сделать с вектором чисел (все-таки больше мы будем работать с числами, так что сосредоточимся на этом) - посчитать статистические характеристики. Это все можно делать с помощью встроенных функций: 

```{r stat_char}
#Создаем вектор случайных равномерно распределенных от 0 до 100 чисел 
x <- runif(1000, 0, 100)
#Считаем основные статистические характеристики
min(x) # минимум
max(x) # максимум
range(x) # размах = максимум - минимум
mean(x) # среднее арифметическое
median(x) # медиана
var(x) # дисперсия (variation)
sd(x) # среднеквадратическое отклонение (standard deviation)
sum(x) # сумма
```

Но это еще не все - это самое простое. Чем силен язык R, так это тем, что вектор в нем - базовая конструкция. Из-за этого все вычисления с векторами происходят также легко, как мы складываем числа в голове. При этом разработчики R знают свои сильные стороны и все больше и больше совершенствуют возможности языка для удобства работы с данными. Не понимаете пока, что я имею ввиду? Посмотрите на самые простые примеры, которые, тем не менее, демонстрируют суть такого подхода: 

```{r vec_oper}
#Создаем вектор х как последовательность чисел
x <- 1:10 

#Умножаем весь вектор на 15 одновременно 
x <- x * 15

#Поэлементно извлекаем корень из всего вектора
x <- sqrt(x)

#Создаем новый вектор такой же размерности и делим один на другой
y <- seq(from = 3, by = 0.5, length.out = length(x))
x <- x/y

print(x)
```

Вы уже начали понимать, что я имел ввиду? :) Никаких циклов, никаких специальных функций - просто работает с вектором, будто это одно число! Это очень ценно, на самом деле, в реальных задачах. ведь это напрямую влияет на удобство аналитика и на читаемость кода. Это очень "тепличные" примеры, но таким же способом можно работать и с более сложными конструкциями, пользовательскими функциями и так далее. Возможности огромны!

Что еще хотелось бы сказать про вектора - хотелось бы остановиться на операторе **ifelse** и на **описательных статистиках**. 

С **ifelse** все просто - этот оператор позволяет в компактной форме проверить некоторое условие и создать новый вектор, заполнив его значениями, на основании проверки. 

```{r ifelse}
#Создаем вектор х как последовательность 0 и 1 с помощью еще одной функции - sample
x <- sample(c(0,1), 10, replace = TRUE)
print(x)

#Проверяем условие x == 1
print(x == 1)

#Создаем вектор, который содержит "Единица", если в x стоит 1 и "Ноль", если 0. 
vec <- ifelse(x == 1, 'Единица', 'Ноль')

print(vec)
```

И последнее по векторам - для получение короткого summary мы можем использовать одноименную функцию **summary()**. Это касается, кстати, не только векторов, но и любых структур. Для количественных переменных получим статистические данные, для качественных - количество вхождений. 

```{r summary_vec}
#Создаем численный вектор и выводим summary
x <- rnorm(100, 0, 50)
summary(x) #Получаем статистики

#Создаем логический вектор и выводим summary
x <- c(TRUE, FALSE, TRUE, TRUE, TRUE, FALSE)
summary(x) #Получаем количество вхождений
```

#### Матрицы 

Мы со всех сторон рассмотрели вектора, давайте передем к чуть более сложной конструкции - к матрице. На самом деле, ничего сложного нет: матрица - обобщение вектора на 2 измерения. Также, как и в векторе, матрица должна содержать однородные данные (только числа, например, или только текст). 

Матрица обычно создается с помощью функции **matrix()** с тремя аргументами - начальные данные, количество строк и количество столбцов. 

```{r create_matrix}
#Создаем вектор из 10 чисел и создаем на основании него матрицу 5*2
x <- c(1:10)
mat <- matrix(x, nrow = 5, ncol = 2)
print(mat)
```

По умолчанию матрица заполняется данными по столбцам, это видно выше. Однако, мы можем сделать заполнение по строкам (обычно, кстати, так удобней), добавив параметр ``` byrow = TRUE ```. 

```{r create_matrix_byrow}
mat_byrow <- matrix(x, nrow = 5, ncol = 2, byrow = TRUE)
print(mat_byrow)
```

Индексация в матрицах работает, как и в векторах, только указать нужно положение ячейки - номер соответствующих строки и столбца: 

```{r matrix_indexing}
#Извлекаем отдельную ячейку матрицы
mat[3,1]

#Извлекаем строку (первый индекс - строка)
mat[3,]

#Извлекаем столбец (второй индекс - столбец)
mat[,2]
```

Извлекать мы можем и отдельные ячейки, и строки, и столбцы. Как это делается, показано выше. Можем также извлечь, например, диапазон строк или диапазон ячеек: 

```{r matrix_indexing_2}
#Извлекаем 2 ячейки из 3 строки
mat[3,1:2]

#Извлекаем 1,3,5 строки
mat[c(1,3,5),]

#Извлекаем 1-2 столбец
mat[,1:2]
```

К матрицам можно применять аналогичные операции, как было с векторами, например: 

```{r matrix_oper}
#Возводим все элементы матрицы в квадрат
mat^2

#Считаем сумму всех элементов
sum(mat)

#Сортируем элементы матрицы - на выходе получим вектор
sort(mat)

#Получаем summary
summary(mat)
```

Также не стоит забывать про традиционные матричные операции - транспонирование, матричное умножение, поиск определителя, обращение матриц и прочее. 

```{r matrix_oper_2}
#Создадим новую матрицу, квадратную (число строк = число столбцов)
x <- rnorm(9, 0, 100)
mat <- matrix(x, nrow = 3, ncol = 3)

#Транспонируем
t(mat)

#Считаем определитель
det(mat)

#Обращаем
solve(mat)

#Матрично умножаем исходную матрицу на транспонированную 
mat %*% t(mat)
```

Не будем сейчас подробно останавливаться на математике, но отмечу - если Вы хотите работать в области, связанной с Data Science, основы линейной алгебры для Вас - must have. 

Вернемся к матрицам. Что еще полезного может быть? Например, поиск элемента. Допустим, нам нужно найти, какая позиция в матрице у элемента, который равен ```x[5]```. Сделаем это, используя ```which()```!

```{r matrix_which}
which(mat == x[5], arr.ind = TRUE)
```

Еще из часто используемого - функции **cbind()** и **rbind()**. Эти фукнции позволяют добавлять строки/столбцы к уже существующим матрицам, а также создавать матрицы из векторов. Зачастую это бывает очень полезно. Разница между ними на поверхности - **rbind** (от row) сцепляет по строкам, а **cbind** (от column) - по столбцам. 

```{r rbind_cbind}
#Создаем вектор х
x <- 1:10
#Создаем вектор у, возводя х в квадрат 
y <- x**2

#Объединяем
z <- cbind(x,y) #по столбцам
z1 <- rbind(x,y) #по строкам

print(z)
print(z1)
```

Таким же способом мы можем присоединить к *z* и *z1* другие строки/столбцы. 

**Замечание.** Соединяя строки и столбцы, следите за типом данных. Если Вы добавите к численной матрице строку из символов, то вся матрица станет символьной, и при попытке, например, посчитать определитель, Вы неизбежно получите ошибку!

### Разнородные структуры. 

#### Фреймы

Фрейм - обобщенное понятие матрицы. Здесь у нас уже нет никаких ограничений на тип данных - можем хранить, что угодно. 

Для создания фреймов используется функция **data.frame()**: 

```{r create_df}
#Создаем вектор х из чисел 
digits <- 1:4
#Создаем вектор у из символов
letters <- c("a", "b", "c", "d")

#Объединяем в data.frame
df <- data.frame(digits, letters, stringsAsFactors = FALSE)
df
```

Обратите внимание - нет никаких кавычек у чисел. Теперь все нормально - числа это числа, а буквы это буквы. Можем посмотреть структуру и убедиться в этом. При создании фрейма специально указал дополнительный аргумент ```stringsAsFactors = FALSE```, чтобы символы интерпретировались именно как текст, а не как факторы (о них подробней позже). 

```{r str_df}
str(df)
```

Еще один момент - посмотрите на заголовки строк и столбцов, теперь у нас колонки носят названия исходных векторов, а строки занумерованы цифрами. Чтобы получить названия всех столбцов, можно использовать функцию ```colnames()```: 

```{r colnames_df}
colnames(df)
```

Мы можем добавлять к существующим фреймам новые строки и столбцы. Например, добавим столбец с числами: 

```{r cdind_df}
#Берем логарифм от вектора digits
new_col <- log(digits)

df <- cbind(df, new_col)

df
```

Появился новый столбец new_col (название взято из названия вектора). 

Обращаться к элементам мы можем, как матрицах, либо используя оператор ```$``` для ссылки на столбец: 

```{r index_df}
df[2,3]
df$new_col
df$digits[2:3]
```

Чтобы присоединить к существующему фрейму строку, нужно выполнить следующие действия: 

```{r rbind_df}
#1. Создаем фрейм из одной строки. Порядок элементов должен совпадать с порядком в фрейме
new_row <- data.frame(7, "y", 28)

#2. Делаем названия у этого мини-фрема, как у основного
colnames(new_row) <- colnames(df)

#3. Используем rbind
df <- rbind(df, new_row)

df
```

Может возникнуть ситуация, когда Вам нужно отсортировать весь фрейм по значениям какого-то одного поля. Тогда делаем так: 

- Сортируем нужное поле
- Индексируем строки фрейма полученной последовательностью индексов

Например: 

```{r sort_df}
#Узнаем последовательность элементов в new_col
indexes <- order(df$new_col, decreasing = TRUE)
indexes

#Выводим весь фрейм на основании полученных индексов 
df[indexes, ]
```

К фреймам можно применять функцию ```summary()```, как и к однородным структурам: 

```{r summary_df}
summary(df)
```

Еще из полезного - мы можем менять названия столбцов в фреймах: 

```{r rename_df}
colnames(df) <- c("col1", "col2", "col3")
df
```

Видно, что названия поменялись. 

Вообще, основная работа аналитиков и Data Scientist-ов происходит именно с фреймами. Огромное количество библиотек заточено именно под работу с этим типом данных; существуют более продвинутые и удобные конструкции (о них поговорим позже). Соответственно, стоит особенно внимательно на стадии изучения поработать с этим типом - он бывает немного непривычен, но, уверен, Вы быстро его освоите. 

#### Списки 

Списки или lists - самые общие контейнеры данных. Они могут содержать в себе разнородную информацию разного типа и разной длины. В один список мы можем поместить одновременно и фрейм, и вектор, и одно число, и что угодно еще. Ничего нового и сложного в работе с list нет, поэтому просто продемонстрируем, как с этим работать. 

```{r lists}

l <- list(dataframe = df, vector = c(1:10), digit = 3, letters = c("a", "b"), date = Sys.Date())

str(l)
```

Мы создали ```list l```, заполнили его самыми разными данными (причем всем дали имена) - и датафреймом, и вектором, и числом, и последовательностью символов, и даже датой! При отображении структуры это все хорошо видно. 

Извлечь элемент списка мы можем либо с помощью индекса и двойных квадратных скобок ```[[]]```, либо с помощью оператора ```$```. 

```{r index_lists}

l$vector

l[['dataframe']]
```

Функционал list достаточно удобен, этот формат часто возвращается функциями, но проводить обработку данных в таком виде не очень удобно - обычно стараются придерживаться фреймов. 

#### Факторы

В статистических и прочих ислледования все данные часто группируют по некоторым признакам, например, пол/социальный статус/место жительства и так далее. В R существует специальный класс, факторы, который предназначен для хранения кодов уровней номинальных признаков. Часто эти коды хранят в виде чисел, но удобней делать это в виде текста, чтобы не было путаницы. Пока это выглядит не очень понятно, я думаю, так что рассморим пример. 

Пусть мы провели опрос - довольны ли местные жители уровнем зарплат. Опросили 10 человек - 4 не довольны, а 6 довольны. У нас, по сути, две категории, и мы можем их "закодировать", например, с помощью 0 и 1. Давайте занесем наши результаты в среду R: 

```{r factors}
results <- c(0,0,1,1,1,0,0,1,1,1)
results
```

Однако, у нас получился вектор чисел, а мы-то хотели "закодировать". В таком случае, нам нужно в явном виде указать программе, что у нас не просто вектор чисел, а именно "уровни". 

```{r factors_1}
results <- factor(results, levels = c(0,1))
results
```

Теперь мы видим, что у нас появилась информация об уровнях и система воспринимает этот вектор именно как набор "кодов". Но кодировка числами может привести к ошибкам или недопониманиям - давайте перекодируем лучше словами. 

```{r factors_2}
levels(results) <- c("no", "yes")
results
```

Теперь уровни из 0 и 1 превратились да/нет. Так намного лучше. 

На самом деле, это все выглядит несколько непонятно и бесполезно, но это не так. По ходу работы с разными библиотеками, Вы поймете, что это: 

- удобно 
- необходимо при работе некоторых важных функций

Так что принебрегать факторами не стоит, но работать с ними надо аккуратно - с ними постоянно бывают ошибки!

## Заключение и summary

Итак, мы рассмотрели все основные типы данных, в том числе сложные, а также освоили весь основной функционал для дальнейшей работы. Давайте подытожим все вышесказанное: 

**основные типы данных**

- numeric
- integer 
- character
- logical 
- complex

**Виды структур данных**

- однородные структуры
- неоднородные структуры 

**Основные однородные структуры**

- вектора
- матрицы 

**Основные неоднородные структуры**

- фреймы
- списки 
- факторы

Есть еще некоторые структуры, которые мы тут не рассматривали (например, ```tibble```). В любом случае, рассмотренные выше понятия - основы. Все что будет встречаться нам далее - обертки и модификации основных инструментов. 
