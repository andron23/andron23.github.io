---
title: "R Course Часть 3 Обработка и очистка данных"
author: "Alexanyan Andron"
output: 
  html_document:
   toc: TRUE
   theme: "readable"
   highlight: "textmate"
---

```{r setup3, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Часть 3 Обработка и очистка данных 

В предыдущей лекции мы рассмотрели загрузку данных в систему для дальнейшей работы с ними. Теперь же давайте перейдем непосредственно к обработке! Мы рассмотрим два основных пункта:

- подготовка и очистка данных
- обработка данных

Итак, начнем по порядку. 

## Подготовка и очистка данных 

Давайте для начала загрузим xlsx-файл, на примере которого мы будем разбирать функционал по подготовке данных. У нас будет несколько разных таблиц на разных листах Excel-книги, пока загрузим только данные с первого листа. Используем пакет ```readxl```. 

```{r connect_readxl, include = FALSE}
library(readxl)
```

```{r loading_data}
df <- read_excel('Lesson 3.xlsx', sheet = 1)
df
```

Итак, мы получили таблицу формата ```tibble```. Пришло время поговорить об этом формате поподробней, так как вся последующая обработка будет происходить с помощью библиотеки ```tidyverse```, где на ```tibble``` сделан основной упор. 

Что же такое ```tibble``` и чем он отличается, например, от стандартного фрейма? Основной смысл такой - ```tibble``` служит для хранения и удобной обработки **"аккуратных данных"**. Конечно, мы туда можем засунуть что угодно (как мы только что и сделали), но задача именно такая: свести все к концепции **tidy data**. 

Но что подразумевается под **"аккуратными данными"**? Есть три основных постулата: 

1. Каждая переменная находится в отдельном столбце. Т.е. есть у нас пол - заведем отдельный столбец. Есть возраст - тоже отдельный. И так далее. 
2. Каждое наблюдение хранится в отдельной строке. Т.е. если у нас есть описание какого-то человека (например: имя, пол, возраст, личные данные), то мы должны для него выделить отдельную строку и никак иначе. 
3. Каждая отдельная сущность хранится в отдельной таблице. Т.е. если мы описываем котов и людей, не надо все заполнять в одну таблицу и ставить в поле "цвет хвоста" у людей NULL или что-то еще. 

Таким образом, все функции библиотеки ```tidyverse``` направлены на приведение наших данных к такому формату и дальнейшей работе с такими ```tibble```. 

Ну что, немного теории мы получили, можем переходить к практике. Подключаем библиотеку ```tidyr``` из семейства ```tidyverse``` и начинаем работу с нашей "грязной" таблицей. 

```{r connect_tidyr, results = 'hide'}
library(tidyr)
```

Для начала давайте повнимательней посмотрим на нашу таблицу еще разок и осознаем, что с ней не так. У нас есть строки с предметами, а также информация по количеству мальчиков и девочек, которые в разных классах этот предмет сдавали. Сразу же напрашивается замечание: у нас нарушен первый постулат - переменные пол и класс хранятся не в разных столбцах. Автоматически из-за этого нарушается и второй постулат - отдельные измерения хранятся не в отдельных строках, а как бы сгруппированы. С третьим постулатом все нормально, просто потому что у нас всего одна таблица :) 

Итак, наша ближайшая задача - привести таблицу к "аккуратному" виду. Как должна выглядеть наша таблица после всех преобразований? Очевидно, для соблюдения всех правил у нее должен быть такой формат: 

```Предмет - Класс - Пол - Количество студентов```

При такой структуре мальчики из 1 класса и девочки из 1 класса, которые сдавали Химию будут находиться в разных строках таблицы. 

Давайте перед решением нашей задачи попытаемся ее разбить на структурные пункты (сама библиотека ```tidyr``` крайней проста, но для ее использования нужно привыкнуть к определенной логике). Нам нужно последовательно решить две проблемы: 

- сделать так, чтобы наши заголовки "men_class1" и т.д. стали не переменными, а признаками - т.е. чтобы в каждой строке таблицы появился бы признак "men_class1" и т.д. Условно говоря, результат этого шага должен выглядеть так: 

```{r gather_1, echo = FALSE}
df %>% gather(sex_class, count, -Lesson)
```

- после этого, нам нужно разбить после ```sex_class``` на два отдельных поля: ```sex``` и ```class```. Таким образом, итоговая таблица должна выглядеть так: 

```{r separate_1, echo = FALSE}
df %>% gather(sex_class, count, -Lesson) %>% separate(sex_class, into = c("sex", "class"))
```

Вот и все - за эти два несложных шага мы полностью приведем нашу таблицу к "аккуратному" виду. Для этого нам понадобятся две функции из пакета ```tidyr``` - ```gather()``` и ```separate()```

### gather() и spread()

Поговорим подробнее про функцию ```gather()```, так как именно она поможет нам в решении первого подпункта задачи. 

Функции ```gather()``` и ```spread()``` служат для реорганизации значений в таблицах. 

Функция ```gather()``` превращает названия столбцов в новый ключевой столбец, собирая соответствующие значения исходных столбцов в отдельный столбец значений. Словами это может выглядеть несколько путано, но давайте рассмотрим на нашем примере. 

```{r gather_2}
#Посмотрим структуру нашей таблицы. Нам нужно превратить названия столбцов "men_class1" и т.д. в отдельный столбец, а цифры, которые в этих столбцах содержаться, вывести в новый столбец под названием count. 
df

#С помощью функции gather создаем новый столбец sex_class, в котором будут содержаться заголовки "men_class1" и т.д., а в столбце count - соответствующие значения
df %>% gather('sex_class (key)', 'count (value)', -Lesson)
```

Названия столбцов взяты в кавычки, так как я дополнительно в скобках еще указал тип столбца: ```key``` у столбца с названиями старых столбцов, ```value``` у столбца со значениями. Если бы названия состояли из одного слова, кавычки можно было бы опустить: 

```{r gather_3, results = 'hide'}
df %>% gather(sex_class, count, -Lesson)
```

Аргумент ```-Lesson``` говорит о том, что столбец ```Lesson``` из исходной таблицы в преобразованиях не участвует и остается неизменным. 

Итак, мы видим, что первая часть задачи решилась - теперь наша таблица состоит из трех столбцов: Предмет, Пол-Класс и Количество людей. Но перед тем, как переходить к решению второй части задачи, давайте обсудим еще функцию ```spread()```. Думаю, уже очевидно, что эта функция - полная противоположность функции ```gather()``` и она формирует из уникальных значений какого-то ключевого (```key```) столбца отдельные столбцы со значениями из ```value``` столбца. Можно продемонстрировать это на нашем примере: 

```{r gather_spread}
#Сворачиваем исходную таблицу, как мы делали это раньше и сохраняем ее в переменную df_to_spread
df_to_spread <- df %>% gather(sex_class, count, -Lesson)

#Расформируем обработанную таблицу df_to_spread обратно - сделаем из столбца `sex_class (key)` 4 отдельных столбца со значениями из `count (value)`
df_to_spread %>% spread(sex_class, count)
```

Наверно, постепенно логика Вам уже становится понятна :) Идем дальше. 

### Конвейер %>% 

Перед тем, как перейти наконец к решению второго пункта задачи, давайте остановимся на конвейере. Вы могли заметить, что в коде выше я использовал конструкцию с символами ```%>% ```. Скорее всего, по смыслу Вы уже догадались, что это и зачем нужно, но стоит проговорить отдельно. 

 ```%>% ``` - это конвейер. Он позволяет не сохранять каждое действие в виде отдельной переменной, применяя каждый раз новую функцию к этой переменной, а просто передавать все как бы по конвейеру: сделал действие - передал результат на вход следующей функции - и так далее до бесконечности. Другими словами, эти две конструкции полностью одинаковые с точки зрения конечного результата, но вариант с конвейером намного удобней и понятней: 
 
```{r conv, results = 'hide'}
#Создаем вектор, логарифмируем каждый элемент и формируем фрейм из значений. Каждое действие - отдельная строка, в которой переменная а перезатирается. 
a <- 5:12
a <- a**2
a <- as.data.frame(a)

#Делаем все то же самое, только намного короче и понятней с помощью конвейера. 
a <- 5:12 %>% log() %>% as.data.frame()
```

Это достаточно простой пример, а вот если Вы работаете с продвинутой графикой или даже обрабатываете данные с помощью библиотеки ```tidyverse```, то конвейер для Вас просто необходим. Если Вы мне не верите, то очень быстро сами в этом убедитесь :) 

### separate() и unite()

Итак, наконец-то мы можем перейти к решению второй части нашей задачи. Напомню - мы получили таблицу из трех столбцов, теперь нам осталось разбить столбец ```sex_class``` на два отдельных: ```sex``` и ```class```. 

Эта задача совсем несложная и решается с помощью функции ```separate()``` все из того же пакета ```tidyr```. Чтобы это сделать, достаточно указать 2 аргумента - **какой столбец надо разбить** и **на какие столбцы надо разбить**. Вот и все. Выглядеть в коде это будет так: 


```{r separate}
#Сохраняем результат предыдущего пункта задачи, перезаписывая переменную df
df <- df %>% gather(sex_class, count, -Lesson)

#С помощью separate разбиваем sex_class на два столбца
df %>% separate(sex_class, into = c("sex", "class"))
```

Мы видим, что у нас получилась таблица, в точности, как нам и нужна была. Использовав всего две функции, мы получили очень неплохой результат. А если еще красиво оформить это с помощью конвейера, то Ваш внутренний перфекционист просто возликует :) 
```{r gather_separate_full}
#загружаем исходные данные
df <- read_excel('Lesson 3.xlsx', sheet = 1)

#полностью решаем поставленную задачу
df <- df %>% 
  gather(sex_class, count, -Lesson) %>% 
  separate(sex_class, into = c("sex", "class"))
```

Отлично, задача полностью решена!

Однако, на этом функции в пакете ```tidyr``` не закончились. Давайте еще про них поговорим. 

Если есть ```separate()```, то есть и обратная - ```unite()```. Эта функция позволяет соединять значения из разных столбцов и формировать один новый. Посмотрим на нашем примере. Давайте из итоговой таблицы вернемся обратно на один шаг - опять объединим столбцы ```sex``` и ```class``` в один ```sex_class```. Очевидно, что выглядеть это будет так: 

```{r unite}
#Объединяем sex и class в sex_class
df %>% unite(sex, class, col = sex_class)
```

### Пропущенные значения

А как работать с таблицей, если она не полностью заполнена? Давайте загрузим такую таблицу со второго листа и попробуем что-нибудь с ней сделать. 

```{r loading_data_2}
df <- read_excel('Lesson 3.xlsx', sheet = 2)
df
```

У нас есть несколько основных вариантов: 

- просто удалить строки, где есть NA
- заполнить их самыми частыми значениями из столбца
- заполнить их какими-то конкретными значениями, которые нам подходят

Для реализации всех этих подходов в пакете ```tidyr``` есть специальные функции. Давайте рассмотрим на примерах: 

```{r missing_values}
#Удаляем строки с пропусками с помощью drop_na()
df %>% drop_na()

#Заполняем пропуски самыми частыми значениями в столбце Grade с помощью fill()
df %>% fill(Grade)

#Заполняем пропуски двойками с помощью replace_na()
df %>% replace_na(list(Grade = 2))

#Заполняем пропуски средним значением столбца Grade (предварительно убрав пропуски) с помощью replace_na()
df %>% replace_na(list(Grade = mean(df$Grade, na.rm = TRUE)))

```

## Обработка данных - dplyr

Итак, с очисткой и подготовкой данных мы более-менее разобрались - мы рассмотрели большое количество функций из пакета ```tidyr```. Более подробную информацию, детализированное описание аргументов каждой функции и так далее Вы сможете узнать из официальной документации и во время "хождения по граблям", решая задачи (как учебные, так и боевые). 

Теперь мы можем переходить к следующему этапу работы с нашими данными. Таблицы загружены, очищены, а что делать дальше? Нам от "сырых" данных толку мало - нам же надо создавать какие-то новые столбцы, считать характеристики, генерировать выводы и представлять результаты в виде отчетов. Для начала, нам понадобится библиотека ```dplyr``` все из того же семейства ```tidyverse```. 

```{r dplyr, results = "hide"}
library(dplyr)
```


В этот раз давайте немного отойдем от уже привычной схемы и будем изучать не загруженную из Excel-файла таблицу, а встроенную. Да, действительно, в R содержится достаточно большое количество встроенных таблиц, на примере которых легко изучать язык. Для того, чтобы подключить такую таблицу, достаточно набрать ```data(название таблицы)```. Скорее всего, если Вы работаете в системе RStudio, Вам автоматически выскочит подсказка с названиями доступных таблиц. Нас же интересует конкретная - ```airquality```. 

```{r airquality}
#Загружаем данные
data("airquality")

str(airquality)
```

Мы видим, что наша таблица - фрейм, который состоит из численных данных (даты измерений и неких климатических измерений - уровень озона, уровень солнечной радиации, скорость ветра, температура). При этом, она содержит пропуски, а значит мы сможем применить только что полученные навыки по ликвидации этих пропусков. 

Для начала, давайте сформулируем себе задачи, чтобы понимать, что мы вообще должны получить в итоге:

1. заполним пропуски каждой величины средними значениями в зависимости от месяца
2. найдем средние значения всех числовых характеристик в зависимости от месяца
3. выберем данные только за май и посчитаем характеристики за один месяц

Итак, начнем. Библиотеку мы подключили, можем перейти непосредственно к работе с данными. 

### mutate() и group_by()

Для того чтобы выполнить первый пункт нашего задания, давайте сначала посмотрим, а в каких столбцах у нас вообще присутствуют пропуски? Сделаем это с помощью уже известной нам функции ```summary()```: 

```{r summary_na}
summary(airquality)
```

Мы видим, что ```NA``` у нас есть только в столбце с Озоном и Радиацией. Их и будем убирать. Мы договорились, что нам нужно заполнить каждый пропуск средним значением величины в конкретном месяце. То есть, если у нас пропуск в Озоне за май, то мы должны поставить туда среднее значение Озона за май. Если пропуск в Радиации за июль - ставим среднее значение Радиации именно за июль. С одной стороны, звучит несложно, но как это сделать максимально красиво? Будем пользоваться только функциями библиотеки ```dplyr```. 

```{r replace_na_airquality}

aq <- airquality %>% #берем исходную таблицу
  group_by(Month) %>% #группируем по месяцам
  mutate(Ozone = replace(Ozone, is.na(Ozone), mean(Ozone, na.rm = TRUE))) %>% #заполняем пропуски в Озоне средними значениями по месяцам
  mutate(Solar.R = replace(Solar.R, is.na(Solar.R), mean(Solar.R, na.rm = TRUE))) #заполняем пропуски в Радиации средними значениями по месяцам

aq
```

Вот и все, первое задание готово. Но что тут, собственно, произошло? Мы видим две новые для нас функции - ```group_by()``` и ```mutate()```. 

Очевидно, что ```group_by()``` выполняет группировку таблицы по некоторому признаку (или нескольким признакам). В данном случае, мы разбиваем таблицу на 5 групп в зависимости от месяца. Здесь все просто, вряд ли возникнут какие-то недопонимания. Кстати, чтобы разгруппировать таблицу, нужно использовать функцию ```ungroup()```. 

С функцией ```mutate()``` все не так очевидно. Назначение этой функции - создание новых вычислимых столбцов. Т.е. если у Вас есть таблица с величиной ```А``` и величиной ```Б```, а Вы хотите добавить величину ```С = А/Б```, то в этом Вам поможет ```mutate```. Мы же здесь использовали эту функцию, не для создания новых столбцов, а для изменения уже существующего - мы как бы поменяли значения в некоторых ячейках столбцов ```Ozone``` и ```Solar.R```. 

Хотелось бы отметить, что помимо функции ```mutate()``` существует еще ряд родственных функций, которые мы сейчас не рассматриваем, но они могут быть очень полезны. Например: 

- ```transmutate()``` - создает одни столбцы, другие удаляет
- ```mutate_all()``` - применяет некоторую функцию ко всем столбцам
- ```mutate_if()``` - применяет некоторую функцию к столбцам, которые удовлетворяют условию 
- ```mutate_at()``` - применяет некоторую функцию к выбранным столбцам

Кстати говоря, нашу задачу было бы изящней решить с помощью ```mutate_at()```, например, но мы пока с Вами не разбирали функции, так что оставим как есть - такой вариант тоже имеет право на существование. 

Теперь поподробней разберем то, как именно мы решили поставленную задачу. Все просто, вот эта запись: ``` mutate(Ozone = replace(Ozone, is.na(Ozone), mean(Ozone, na.rm = TRUE)))``` значит: *в столбце Озон(```mutate Ozone```) заменяем те ячейки (```replace```), которые содержат пропуски (```is.na(Ozone)```) на среднее значение Озона по конкретному месяцу, исключая пропуски (```mean(Ozone, na.rm = TRUE)``` + ранее ```group_by(Month)```)*. Вот и все. Аналогично делаем и с Радиацией. 

### summarise()

Давайте перейдем ко второму пункту задания - теперь нам нужно найти средние значения всех числовых характеристик для каждого месяца. 

Для вычисления подытогов (средних значений, максимальных/минимальных значений, сумм, медиан и так далее) по таблице существует специальная функция - ```summarise()```. Пользоваться ей очень легко - достаточно указать *таблицу, которую обрабатываем*, *столбец, по которому считаем характеристику* и *саму характеристику (сумма, среднее и т.д.)*. Вот, например, как бы мы посчитали среднюю радиацию за весь период: 

```{r mean_radiation}

aq %>% 
  ungroup() %>% #Разгруппируем, так как в предыдущем задании мы делали группировку по месяцам
  summarise(mean(Solar.R)) #Считаем среднее
```

Ничего сложного, согласитесь. Однако, наше задание чуть объемней - нам нужно посчитать среднее по все всем числовым характеристикам, а это 4 столбца. Неужели мы будем все 4 столбца указывать в качестве аргумента функции ```summarise()```? Нет, зачем, можно сделать красивей! Как и в случае с ```mutate()```, ```summarise()``` - целое семейство функций. Соответственно, мы можем просто воспользоваться функцией ```summarise_all()``` для решения нашей задачи: 

```{r mean_airquality}
#Таблица aq сгруппирована по месяцам, так и оставляем, нам группировка нужна и в этом задании
aq[-6] %>% #Убираем столбец с днями - он нам тут не нужен
  summarise_all(list(mean)) #Считаем среднее по всем столбцам
```

Мы получили в точности то, что и хотели - информацию о среднем значении каждой климатической характеристики по каждому месяцу. 

### filter() и select()

Давайте теперь перейдем к выполнению последнего пункта задания - расчет характеристик за май месяц. Давайте ограничимся двумя характеристиками (просто чтобы на экран влезло) - среднее и среднеквадратическое отклонение.

Итак, для начала нам нужно отфильтровать данные по месяцу с помощью функции ```filter()```, а потом посчитать итоги уже знакомой нам ```summarise_all()```. 

```{r filter_airquality}

aq %>%
  ungroup() %>% #Убираем группировку
  filter(Month == 5) %>% #Фильтруем май
  select(-c(Month, Day)) %>% #Убираем столбцы с месяцами и днями
  summarise_all(list("mean" = mean, "sd" = sd)) #Считаем характеристики
```

Здесь мы встречаемся еще с двумя новыми функциями - ```filter()``` и ```select()```. Их синтаксис очень интуитивно понятен - в общем случае, нам нужно указывать только *таблицу*  и *что фильтруем/выбираем*. Если мы работаем с конвейером, как сейчас, то указывать нужно только *столбец, который надо убрать/оставить* или *условие фильтрации*. Вот, собственно, и все. Функция ```summarise_all()``` нам уже знакома, так что ее результат понятен - мы для каждого столбца считаем все указанные характеристики. 

Помимо ```filter()``` мы можем использовать еще ряд росдтвенных функций, например: 

- ```distinct()``` для извлечения уникальных строк
- ```sample_frac()``` для извлечения случайного набора строк
- ```slice()``` для извлечения заданных строк

### arrange() 

Мы решили все наши задания, но хотелось бы обратить внимание еще на одну функцию библиотеки ```dplyr``` - функцию ```arrange()```. Ее задача проста - она упорядочивает строки по значениям некоторого столбца. Синтакис крайне прост: *где упорядочиваем* и *по каким значениям упорядочиваем*. Вот пример: 

```{r arrange_airquality}

aq %>%
  ungroup() %>% #Убираем группировку
  arrange(desc(Month)) #Сортируем по убыванию месяца
```

## Заключение 

За этот урок мы рассмотрели достаточно много функций из библиотек ```tidyr``` и ```dplyr``` - основных инструментов аналитика и исследователя при очистке и обработке данных. Естественно, мы осветили не все возможные функции и возможности, их намного больше. Однако, самое основное и нужное мы разобрали - остальное придет в процессе глубокого изучения и решения задачек. 

Мы накопили уже достаточно много материала, теперь нужно рассмотреть еще одну тему - функции, и мы готовы приступать к решению своих первых проектных задач с помощью языка R. 